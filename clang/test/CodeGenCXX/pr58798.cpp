// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals --include-generated-funcs
// RUN: %clang_cc1 -fno-ident -emit-llvm %s -o - -triple x86_64-linux-gnu -fexceptions -fcxx-exceptions | FileCheck %s








// Forward declarations:

__attribute__((pure)) int callee_with_clang_attr(int a);
int callee_with_cxx_attr(int a) noexcept;

// Calls to forward declarations:

__attribute__((pure)) int early_caller_of_callee_with_clang_attr_with_clang_attr(int a) {
  return callee_with_clang_attr(a);
}

int early_caller_of_callee_with_clang_attr_with_cxx_attr(int a) noexcept {
  return callee_with_clang_attr(a);
}

__attribute__((pure)) int early_caller_of_callee_with_cxx_attr_with_clang_attr(int a) {
  return callee_with_cxx_attr(a);
}

int early_caller_of_callee_with_cxx_attr_with_cxx_attr(int a) noexcept {
  return callee_with_cxx_attr(a);
}

// Definitions:

__attribute__((pure)) int callee_with_clang_attr(int a) {
  if(a)
    throw int(42);
  return 24;
}

int callee_with_cxx_attr(int a) noexcept {
  if(a)
    throw int(42);
  return 24;
}

// Calls to definitions:

__attribute__((pure)) int late_caller_of_callee_with_clang_attr_with_clang_attr(int a) {
  return callee_with_clang_attr(a);
}

int late_caller_of_callee_with_clang_attr_with_cxx_attr(int a) noexcept {
  return callee_with_clang_attr(a);
}

__attribute__((pure)) int late_caller_of_callee_with_cxx_attr_with_clang_attr(int a) {
  return callee_with_cxx_attr(a);
}

int late_caller_of_callee_with_cxx_attr_with_cxx_attr(int a) noexcept {
  return callee_with_cxx_attr(a);
}
//.
// CHECK: @_ZTIi = external constant ptr
//.
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone willreturn memory(read)
// CHECK-LABEL: define {{[^@]+}}@_Z54early_caller_of_callee_with_clang_attr_with_clang_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z22callee_with_clang_attri(i32 noundef [[TMP0]]) #[[ATTR4:[0-9]+]]
// CHECK-NEXT:    ret i32 [[CALL]]
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone willreturn memory(read)
// CHECK-LABEL: define {{[^@]+}}@_Z22callee_with_clang_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP0]], 0
// CHECK-NEXT:    br i1 [[TOBOOL]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
// CHECK:       if.then:
// CHECK-NEXT:    [[EXCEPTION:%.*]] = call ptr @__cxa_allocate_exception(i64 4) #[[ATTR5:[0-9]+]]
// CHECK-NEXT:    store i32 42, ptr [[EXCEPTION]], align 16
// CHECK-NEXT:    call void @__cxa_throw(ptr [[EXCEPTION]], ptr @_ZTIi, ptr null) #[[ATTR6:[0-9]+]]
// CHECK-NEXT:    unreachable
// CHECK:       if.end:
// CHECK-NEXT:    ret i32 24
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone
// CHECK-LABEL: define {{[^@]+}}@_Z52early_caller_of_callee_with_clang_attr_with_cxx_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z22callee_with_clang_attri(i32 noundef [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[CALL]]
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone willreturn memory(read)
// CHECK-LABEL: define {{[^@]+}}@_Z52early_caller_of_callee_with_cxx_attr_with_clang_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z20callee_with_cxx_attri(i32 noundef [[TMP0]]) #[[ATTR7:[0-9]+]]
// CHECK-NEXT:    ret i32 [[CALL]]
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone
// CHECK-LABEL: define {{[^@]+}}@_Z20callee_with_cxx_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR1]] personality ptr @__gxx_personality_v0 {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP0]], 0
// CHECK-NEXT:    br i1 [[TOBOOL]], label [[IF_THEN:%.*]], label [[IF_END:%.*]]
// CHECK:       if.then:
// CHECK-NEXT:    [[EXCEPTION:%.*]] = call ptr @__cxa_allocate_exception(i64 4) #[[ATTR5]]
// CHECK-NEXT:    store i32 42, ptr [[EXCEPTION]], align 16
// CHECK-NEXT:    invoke void @__cxa_throw(ptr [[EXCEPTION]], ptr @_ZTIi, ptr null) #[[ATTR6]]
// CHECK-NEXT:    to label [[UNREACHABLE:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
// CHECK:       if.end:
// CHECK-NEXT:    ret i32 24
// CHECK:       terminate.lpad:
// CHECK-NEXT:    [[TMP1:%.*]] = landingpad { ptr, i32 }
// CHECK-NEXT:    catch ptr null
// CHECK-NEXT:    [[TMP2:%.*]] = extractvalue { ptr, i32 } [[TMP1]], 0
// CHECK-NEXT:    call void @__clang_call_terminate(ptr [[TMP2]]) #[[ATTR8:[0-9]+]]
// CHECK-NEXT:    unreachable
// CHECK:       unreachable:
// CHECK-NEXT:    unreachable
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone
// CHECK-LABEL: define {{[^@]+}}@_Z50early_caller_of_callee_with_cxx_attr_with_cxx_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z20callee_with_cxx_attri(i32 noundef [[TMP0]]) #[[ATTR7]]
// CHECK-NEXT:    ret i32 [[CALL]]
//
//
// CHECK: Function Attrs: noconvergent noinline noreturn nounwind
// CHECK-LABEL: define {{[^@]+}}@__clang_call_terminate
// CHECK-SAME: (ptr noundef [[TMP0:%.*]]) #[[ATTR3:[0-9]+]] comdat {
// CHECK-NEXT:    [[TMP2:%.*]] = call ptr @__cxa_begin_catch(ptr [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    call void @_ZSt9terminatev() #[[ATTR8]]
// CHECK-NEXT:    unreachable
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone willreturn memory(read)
// CHECK-LABEL: define {{[^@]+}}@_Z53late_caller_of_callee_with_clang_attr_with_clang_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z22callee_with_clang_attri(i32 noundef [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[CALL]]
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone
// CHECK-LABEL: define {{[^@]+}}@_Z51late_caller_of_callee_with_clang_attr_with_cxx_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z22callee_with_clang_attri(i32 noundef [[TMP0]]) #[[ATTR4]]
// CHECK-NEXT:    ret i32 [[CALL]]
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone willreturn memory(read)
// CHECK-LABEL: define {{[^@]+}}@_Z51late_caller_of_callee_with_cxx_attr_with_clang_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z20callee_with_cxx_attri(i32 noundef [[TMP0]]) #[[ATTR7]]
// CHECK-NEXT:    ret i32 [[CALL]]
//
//
// CHECK: Function Attrs: mustprogress noconvergent noinline nounwind optnone
// CHECK-LABEL: define {{[^@]+}}@_Z49late_caller_of_callee_with_cxx_attr_with_cxx_attri
// CHECK-SAME: (i32 noundef [[A:%.*]]) #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A_ADDR:%.*]] = alloca i32, align 4
// CHECK-NEXT:    store i32 [[A]], ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[A_ADDR]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z20callee_with_cxx_attri(i32 noundef [[TMP0]]) #[[ATTR7]]
// CHECK-NEXT:    ret i32 [[CALL]]
//
//.
// CHECK: attributes #0 = { mustprogress noconvergent noinline nounwind optnone willreturn memory(read) "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #1 = { mustprogress noconvergent noinline nounwind optnone "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #2 = { noconvergent }
// CHECK: attributes #3 = { noconvergent noinline noreturn nounwind "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+cx8,+mmx,+sse,+sse2,+x87" }
// CHECK: attributes #4 = { noconvergent nounwind willreturn memory(read) }
// CHECK: attributes #5 = { nounwind }
// CHECK: attributes #6 = { noreturn }
// CHECK: attributes #7 = { noconvergent nounwind }
// CHECK: attributes #8 = { noreturn nounwind }
//.
// CHECK: !0 = !{i32 1, !"wchar_size", i32 4}
//.
