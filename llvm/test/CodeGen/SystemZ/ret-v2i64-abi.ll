; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc -mtriple=s390x-linux-gnu < %s | FileCheck -check-prefixes=LINUX,LINUX-BASE %s
; RUN: llc -mtriple=s390x-linux-gnu -mcpu=z13 < %s | FileCheck -check-prefixes=LINUX,LINUX-Z13 %s

; FIXME: Why do the zos checks not get emitted?
; RUN: llc -mtriple=s390x-ibm-zos < %s | FileCheck -check-prefixes=ZOS,ZOS-BASE %s
; RUN: llc -mtriple=s390x-ibm-zos -mcpu=z13 < %s | FileCheck -check-prefixes=ZOS,ZOS-Z13 %s


define <2 x i64> @ret_v2i64(ptr %ptr) {
; LINUX-BASE-LABEL: ret_v2i64:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    lg %r0, 0(%r2)
; LINUX-BASE-NEXT:    lg %r3, 0(%r2)
; LINUX-BASE-NEXT:    lgr %r2, %r0
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_v2i64:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v24, 0(%r2), 1
; LINUX-Z13-NEXT:    br %r14
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %insertelement.0 = insertelement <2 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <2 x i64> %insertelement.0, i64 %elt1, i32 1
  ret <2 x i64> %insertelement.1
}

define { <2 x i64>, <2 x i64> } @ret_v2i64_x2(ptr %ptr) {
; LINUX-BASE-LABEL: ret_v2i64_x2:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    lg %r0, 0(%r2)
; LINUX-BASE-NEXT:    lg %r1, 0(%r2)
; LINUX-BASE-NEXT:    lg %r4, 0(%r2)
; LINUX-BASE-NEXT:    lg %r5, 0(%r2)
; LINUX-BASE-NEXT:    lgr %r2, %r0
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_v2i64_x2:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    lg %r0, 0(%r2)
; LINUX-Z13-NEXT:    vlrepg %v26, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v26, 0(%r2), 1
; LINUX-Z13-NEXT:    br %r14
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %elt2 = load volatile i64, ptr %ptr
  %elt3 = load volatile i64, ptr %ptr

  %insertelement.0 = insertelement <2 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <2 x i64> %insertelement.0, i64 %elt1, i32 1

  %insertelement.2 = insertelement <2 x i64> poison, i64 %elt2, i32 0
  %insertelement.3 = insertelement <2 x i64> %insertelement.2, i64 %elt3, i32 1

  %insertval.0 = insertvalue { <2 x i64>, <2 x i64> } poison, <2 x i64> %insertelement.0, 0
  %insertval.1 = insertvalue { <2 x i64>, <2 x i64> } %insertval.0, <2 x i64> %insertelement.3, 1

  ret { <2 x i64>, <2 x i64> } %insertval.1
}

define { <2 x i64>, <2 x i64>, <2 x i64> } @ret_v2i64_x3(ptr %ptr) {
; LINUX-BASE-LABEL: ret_v2i64_x3:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    lg %r0, 0(%r3)
; LINUX-BASE-NEXT:    lg %r1, 0(%r3)
; LINUX-BASE-NEXT:    lg %r1, 0(%r3)
; LINUX-BASE-NEXT:    lg %r4, 0(%r3)
; LINUX-BASE-NEXT:    lg %r5, 0(%r3)
; LINUX-BASE-NEXT:    lg %r3, 0(%r3)
; LINUX-BASE-NEXT:    stg %r3, 40(%r2)
; LINUX-BASE-NEXT:    stg %r5, 32(%r2)
; LINUX-BASE-NEXT:    stg %r4, 24(%r2)
; LINUX-BASE-NEXT:    stg %r1, 16(%r2)
; LINUX-BASE-NEXT:    stg %r0, 0(%r2)
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_v2i64_x3:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    lg %r0, 0(%r2)
; LINUX-Z13-NEXT:    vlrepg %v26, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v26, 0(%r2), 1
; LINUX-Z13-NEXT:    vlrepg %v28, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v28, 0(%r2), 1
; LINUX-Z13-NEXT:    br %r14
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %elt2 = load volatile i64, ptr %ptr
  %elt3 = load volatile i64, ptr %ptr
  %elt4 = load volatile i64, ptr %ptr
  %elt5 = load volatile i64, ptr %ptr

  %insertelement.0 = insertelement <2 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <2 x i64> %insertelement.0, i64 %elt1, i32 1

  %insertelement.2 = insertelement <2 x i64> poison, i64 %elt2, i32 0
  %insertelement.3 = insertelement <2 x i64> %insertelement.2, i64 %elt3, i32 1

  %insertelement.4 = insertelement <2 x i64> poison, i64 %elt4, i32 0
  %insertelement.5 = insertelement <2 x i64> %insertelement.4, i64 %elt5, i32 1

  %insertval.0 = insertvalue { <2 x i64>, <2 x i64>, <2 x i64> } poison, <2 x i64> %insertelement.0, 0
  %insertval.1 = insertvalue { <2 x i64>, <2 x i64>, <2 x i64> } %insertval.0, <2 x i64> %insertelement.3, 1
  %insertval.2 = insertvalue { <2 x i64>, <2 x i64>, <2 x i64> } %insertval.1, <2 x i64> %insertelement.5, 2

  ret { <2 x i64>, <2 x i64>, <2 x i64> } %insertval.2
}

define { <2 x i64>, i64 } @ret_v2i64_i64(ptr %ptr) {
; LINUX-BASE-LABEL: ret_v2i64_i64:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    lg %r0, 0(%r2)
; LINUX-BASE-NEXT:    lg %r3, 0(%r2)
; LINUX-BASE-NEXT:    lg %r4, 0(%r2)
; LINUX-BASE-NEXT:    lgr %r2, %r0
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_v2i64_i64:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v24, 0(%r2), 1
; LINUX-Z13-NEXT:    lg %r2, 0(%r2)
; LINUX-Z13-NEXT:    br %r14
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %scalar0 = load volatile i64, ptr %ptr
  %insertelement.0 = insertelement <2 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <2 x i64> %insertelement.0, i64 %elt1, i32 1
  %insertval.0 = insertvalue { <2 x i64>, i64 } poison, <2 x i64> %insertelement.1, 0
  %insertval.1 = insertvalue { <2 x i64>, i64 } %insertval.0, i64 %scalar0, 1
  ret { <2 x i64>, i64 } %insertval.1
}

define { i64, <2 x i64> } @ret_i64_v2i64(ptr %ptr) {
; LINUX-BASE-LABEL: ret_i64_v2i64:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    lg %r3, 0(%r2)
; LINUX-BASE-NEXT:    lg %r4, 0(%r2)
; LINUX-BASE-NEXT:    lg %r2, 0(%r2)
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_i64_v2i64:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v24, 0(%r2), 1
; LINUX-Z13-NEXT:    lg %r2, 0(%r2)
; LINUX-Z13-NEXT:    br %r14
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %scalar0 = load volatile i64, ptr %ptr
  %insertelement.0 = insertelement <2 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <2 x i64> %insertelement.0, i64 %elt1, i32 1
  %insertval.0 = insertvalue { i64, <2 x i64> } poison, i64 %scalar0, 0
  %insertval.1 = insertvalue { i64, <2 x i64> } %insertval.0, <2 x i64> %insertelement.1, 1
  ret { i64, <2 x i64> } %insertval.1
}

define { i64, <2 x i64>, i64 } @ret_i64_v2i64_i64(ptr %ptr) {
; LINUX-BASE-LABEL: ret_i64_v2i64_i64:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    lg %r3, 0(%r2)
; LINUX-BASE-NEXT:    lg %r4, 0(%r2)
; LINUX-BASE-NEXT:    lg %r0, 0(%r2)
; LINUX-BASE-NEXT:    lg %r5, 0(%r2)
; LINUX-BASE-NEXT:    lgr %r2, %r0
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_i64_v2i64_i64:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v24, 0(%r2), 1
; LINUX-Z13-NEXT:    lg %r0, 0(%r2)
; LINUX-Z13-NEXT:    lg %r3, 0(%r2)
; LINUX-Z13-NEXT:    lgr %r2, %r0
; LINUX-Z13-NEXT:    br %r14
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %scalar0 = load volatile i64, ptr %ptr
  %scalar1 = load volatile i64, ptr %ptr
  %insertelement.0 = insertelement <2 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <2 x i64> %insertelement.0, i64 %elt1, i32 1
  %insertval.0 = insertvalue { i64, <2 x i64>, i64 } poison, i64 %scalar0, 0
  %insertval.1 = insertvalue { i64, <2 x i64>, i64 } %insertval.0, <2 x i64> %insertelement.1, 1
  %insertval.2 = insertvalue { i64, <2 x i64>, i64 } %insertval.1, i64 %scalar1, 2
  ret { i64, <2 x i64>, i64 } %insertval.2
}

define <3 x i64> @ret_v3i64(ptr %ptr) {
; LINUX-LABEL: ret_v3i64:
; LINUX:       # %bb.0:
; LINUX-NEXT:    lg %r0, 0(%r2)
; LINUX-NEXT:    lg %r3, 0(%r2)
; LINUX-NEXT:    lg %r4, 0(%r2)
; LINUX-NEXT:    lgr %r2, %r0
; LINUX-NEXT:    br %r14
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %elt2 = load volatile i64, ptr %ptr

  %insertelement.0 = insertelement <3 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <3 x i64> %insertelement.0, i64 %elt1, i32 1
  %insertelement.2 = insertelement <3 x i64> %insertelement.1, i64 %elt2, i32 2
  ret <3 x i64> %insertelement.2
}

define <4 x i64> @ret_v4i64(ptr %ptr) {
; LINUX-BASE-LABEL: ret_v4i64:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    lg %r0, 0(%r2)
; LINUX-BASE-NEXT:    lg %r3, 0(%r2)
; LINUX-BASE-NEXT:    lg %r4, 0(%r2)
; LINUX-BASE-NEXT:    lg %r5, 0(%r2)
; LINUX-BASE-NEXT:    lgr %r2, %r0
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_v4i64:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v24, 0(%r2), 1
; LINUX-Z13-NEXT:    vlrepg %v26, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v26, 0(%r2), 1
; LINUX-Z13-NEXT:    br %r14
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %elt2 = load volatile i64, ptr %ptr
  %elt3 = load volatile i64, ptr %ptr

  %insertelement.0 = insertelement <4 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <4 x i64> %insertelement.0, i64 %elt1, i32 1
  %insertelement.2 = insertelement <4 x i64> %insertelement.1, i64 %elt2, i32 2
  %insertelement.3 = insertelement <4 x i64> %insertelement.2, i64 %elt3, i32 3
  ret <4 x i64> %insertelement.3
}

define { i64, i64, i64, <2 x i64> } @ret_i64_i64_i64_v2i64(ptr %ptr) {
; LINUX-BASE-LABEL: ret_i64_i64_i64_v2i64:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    lg %r0, 0(%r3)
; LINUX-BASE-NEXT:    lg %r1, 0(%r3)
; LINUX-BASE-NEXT:    lg %r4, 0(%r3)
; LINUX-BASE-NEXT:    lg %r5, 0(%r3)
; LINUX-BASE-NEXT:    lg %r3, 0(%r3)
; LINUX-BASE-NEXT:    stg %r3, 32(%r2)
; LINUX-BASE-NEXT:    stg %r5, 24(%r2)
; LINUX-BASE-NEXT:    stg %r4, 16(%r2)
; LINUX-BASE-NEXT:    stg %r1, 8(%r2)
; LINUX-BASE-NEXT:    stg %r0, 0(%r2)
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_i64_i64_i64_v2i64:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    lg %r0, 0(%r2)
; LINUX-Z13-NEXT:    lg %r3, 0(%r2)
; LINUX-Z13-NEXT:    lg %r4, 0(%r2)
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v24, 0(%r2), 1
; LINUX-Z13-NEXT:    lgr %r2, %r0
; LINUX-Z13-NEXT:    br %r14
  %scalar0 = load volatile i64, ptr %ptr
  %scalar1 = load volatile i64, ptr %ptr
  %scalar2 = load volatile i64, ptr %ptr
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %insertelement.0 = insertelement <2 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <2 x i64> %insertelement.0, i64 %elt1, i32 1
  %insertval.0 = insertvalue { i64, i64, i64, <2 x i64> } poison, i64 %scalar0, 0
  %insertval.1 = insertvalue { i64, i64, i64, <2 x i64> } %insertval.0, i64 %scalar1, 1
  %insertval.2 = insertvalue { i64, i64, i64, <2 x i64> } %insertval.1, i64 %scalar2, 2
  %insertval.3 = insertvalue { i64, i64, i64, <2 x i64> } %insertval.2, <2 x i64> %insertelement.1, 3
  ret { i64, i64, i64, <2 x i64> } %insertval.3
}

define { i64, i64, i64, i64, <2 x i64> } @ret_i64_i64_i64_i64_v2i64(ptr %ptr) {
; LINUX-BASE-LABEL: ret_i64_i64_i64_i64_v2i64:
; LINUX-BASE:       # %bb.0:
; LINUX-BASE-NEXT:    stmg %r14, %r15, 112(%r15)
; LINUX-BASE-NEXT:    .cfi_offset %r14, -48
; LINUX-BASE-NEXT:    .cfi_offset %r15, -40
; LINUX-BASE-NEXT:    lg %r0, 0(%r3)
; LINUX-BASE-NEXT:    lg %r1, 0(%r3)
; LINUX-BASE-NEXT:    lg %r4, 0(%r3)
; LINUX-BASE-NEXT:    lg %r5, 0(%r3)
; LINUX-BASE-NEXT:    lg %r14, 0(%r3)
; LINUX-BASE-NEXT:    lg %r3, 0(%r3)
; LINUX-BASE-NEXT:    stg %r3, 40(%r2)
; LINUX-BASE-NEXT:    stg %r14, 32(%r2)
; LINUX-BASE-NEXT:    stg %r5, 24(%r2)
; LINUX-BASE-NEXT:    stg %r4, 16(%r2)
; LINUX-BASE-NEXT:    stg %r1, 8(%r2)
; LINUX-BASE-NEXT:    stg %r0, 0(%r2)
; LINUX-BASE-NEXT:    lmg %r14, %r15, 112(%r15)
; LINUX-BASE-NEXT:    br %r14
;
; LINUX-Z13-LABEL: ret_i64_i64_i64_i64_v2i64:
; LINUX-Z13:       # %bb.0:
; LINUX-Z13-NEXT:    lg %r0, 0(%r2)
; LINUX-Z13-NEXT:    lg %r3, 0(%r2)
; LINUX-Z13-NEXT:    lg %r4, 0(%r2)
; LINUX-Z13-NEXT:    lg %r5, 0(%r2)
; LINUX-Z13-NEXT:    vlrepg %v24, 0(%r2)
; LINUX-Z13-NEXT:    vleg %v24, 0(%r2), 1
; LINUX-Z13-NEXT:    lgr %r2, %r0
; LINUX-Z13-NEXT:    br %r14
  %scalar0 = load volatile i64, ptr %ptr
  %scalar1 = load volatile i64, ptr %ptr
  %scalar2 = load volatile i64, ptr %ptr
  %scalar3 = load volatile i64, ptr %ptr
  %elt0 = load volatile i64, ptr %ptr
  %elt1 = load volatile i64, ptr %ptr
  %insertelement.0 = insertelement <2 x i64> poison, i64 %elt0, i32 0
  %insertelement.1 = insertelement <2 x i64> %insertelement.0, i64 %elt1, i32 1
  %insertval.0 = insertvalue { i64, i64, i64, i64, <2 x i64> } poison, i64 %scalar0, 0
  %insertval.1 = insertvalue { i64, i64, i64, i64, <2 x i64> } %insertval.0, i64 %scalar1, 1
  %insertval.2 = insertvalue { i64, i64, i64, i64, <2 x i64> } %insertval.1, i64 %scalar2, 2
  %insertval.3 = insertvalue { i64, i64, i64, i64, <2 x i64> } %insertval.2, i64 %scalar3, 3
  %insertval.4 = insertvalue { i64, i64, i64, i64, <2 x i64> } %insertval.3, <2 x i64> %insertelement.1, 4
  ret { i64, i64, i64, i64, <2 x i64> } %insertval.4
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; ZOS: {{.*}}
; ZOS-BASE: {{.*}}
; ZOS-Z13: {{.*}}
