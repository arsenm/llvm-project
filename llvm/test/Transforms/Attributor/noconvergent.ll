; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-max-iterations-verify -attributor-annotate-decl-cs -attributor-max-iterations=2 -S < %s | FileCheck %s --check-prefixes=CHECK,TUNIT
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s | FileCheck %s --check-prefixes=CHECK,CGSCC

define i32 @nonleaf() {
; TUNIT: Function Attrs: noconvergent nofree norecurse nosync nounwind willreturn memory(none)
; TUNIT-LABEL: define {{[^@]+}}@nonleaf
; TUNIT-SAME: () #[[ATTR0:[0-9]+]] {
; TUNIT-NEXT:    ret i32 0
;
; CGSCC: Function Attrs: noconvergent nofree nosync nounwind willreturn memory(none)
; CGSCC-LABEL: define {{[^@]+}}@nonleaf
; CGSCC-SAME: () #[[ATTR0:[0-9]+]] {
; CGSCC-NEXT:    [[A:%.*]] = call noundef i32 @leaf() #[[ATTR7:[0-9]+]]
; CGSCC-NEXT:    ret i32 [[A]]
;
  %a = call i32 @leaf()
  ret i32 %a
}

define i32 @leaf() {
; TUNIT: Function Attrs: noconvergent nofree norecurse nosync nounwind willreturn memory(none)
; TUNIT-LABEL: define {{[^@]+}}@leaf
; TUNIT-SAME: () #[[ATTR0]] {
; TUNIT-NEXT:    ret i32 0
;
; CGSCC: Function Attrs: noconvergent nofree norecurse nosync nounwind willreturn memory(none)
; CGSCC-LABEL: define {{[^@]+}}@leaf
; CGSCC-SAME: () #[[ATTR1:[0-9]+]] {
; CGSCC-NEXT:    ret i32 0
;
  ret i32 0
}

declare i32 @extern_noconvergent() noconvergent

declare i32 @extern_convergent()

define i32 @call_extern_convergent() {
; CHECK-LABEL: define {{[^@]+}}@call_extern_convergent() {
; CHECK-NEXT:    [[A:%.*]] = call i32 @extern_convergent()
; CHECK-NEXT:    ret i32 [[A]]
;
  %a = call i32 @extern_convergent()
  ret i32 %a
}

define i32 @extern_noconvergent_call() {
; TUNIT: Function Attrs: noconvergent
; TUNIT-LABEL: define {{[^@]+}}@extern_noconvergent_call
; TUNIT-SAME: () #[[ATTR1:[0-9]+]] {
; TUNIT-NEXT:    [[A:%.*]] = call i32 @extern_noconvergent() #[[ATTR1]]
; TUNIT-NEXT:    ret i32 [[A]]
;
; CGSCC: Function Attrs: noconvergent
; CGSCC-LABEL: define {{[^@]+}}@extern_noconvergent_call
; CGSCC-SAME: () #[[ATTR2:[0-9]+]] {
; CGSCC-NEXT:    [[A:%.*]] = call i32 @extern_noconvergent() #[[ATTR2]]
; CGSCC-NEXT:    ret i32 [[A]]
;
  %a = call i32 @extern_noconvergent()
  ret i32 %a
}

define i32 @indirect_noconvergent_call(ptr %f) {
; TUNIT: Function Attrs: noconvergent
; TUNIT-LABEL: define {{[^@]+}}@indirect_noconvergent_call
; TUNIT-SAME: (ptr nocapture nofree noundef nonnull [[F:%.*]]) #[[ATTR1]] {
; TUNIT-NEXT:    [[A:%.*]] = call i32 [[F]]() #[[ATTR1]]
; TUNIT-NEXT:    ret i32 [[A]]
;
; CGSCC: Function Attrs: noconvergent
; CGSCC-LABEL: define {{[^@]+}}@indirect_noconvergent_call
; CGSCC-SAME: (ptr nocapture nofree noundef nonnull [[F:%.*]]) #[[ATTR2]] {
; CGSCC-NEXT:    [[A:%.*]] = call i32 [[F]]() #[[ATTR2]]
; CGSCC-NEXT:    ret i32 [[A]]
;
  %a = call i32 %f() noconvergent
  ret i32 %a
}

; Give indirect_non_convergent_call the norecurse attribute so we get a
; "Function Attrs" comment in the output.

define i32 @indirect_non_convergent_call(ptr %f) norecurse {
; TUNIT: Function Attrs: norecurse
; TUNIT-LABEL: define {{[^@]+}}@indirect_non_convergent_call
; TUNIT-SAME: (ptr nocapture nofree noundef nonnull [[F:%.*]]) #[[ATTR2:[0-9]+]] {
; TUNIT-NEXT:    [[A:%.*]] = call i32 [[F]]()
; TUNIT-NEXT:    ret i32 [[A]]
;
; CGSCC: Function Attrs: norecurse
; CGSCC-LABEL: define {{[^@]+}}@indirect_non_convergent_call
; CGSCC-SAME: (ptr nocapture nofree noundef nonnull [[F:%.*]]) #[[ATTR3:[0-9]+]] {
; CGSCC-NEXT:    [[A:%.*]] = call i32 [[F]]()
; CGSCC-NEXT:    ret i32 [[A]]
;
  %a = call i32 %f()
  ret i32 %a
}

declare void @llvm.nvvm.barrier0()

define i32 @intrinsic() {
  ; Implicitly convergent, because the intrinsic is convergent.
; TUNIT: Function Attrs: noconvergent norecurse nounwind
; TUNIT-LABEL: define {{[^@]+}}@intrinsic
; TUNIT-SAME: () #[[ATTR4:[0-9]+]] {
; TUNIT-NEXT:    call void @llvm.nvvm.barrier0()
; TUNIT-NEXT:    ret i32 0
;
; CGSCC: Function Attrs: noconvergent norecurse nounwind
; CGSCC-LABEL: define {{[^@]+}}@intrinsic
; CGSCC-SAME: () #[[ATTR5:[0-9]+]] {
; CGSCC-NEXT:    call void @llvm.nvvm.barrier0()
; CGSCC-NEXT:    ret i32 0
;
  call void @llvm.nvvm.barrier0()
  ret i32 0
}

define i32 @convergent_intrinsic_noconvergent_callsite() {
; TUNIT: Function Attrs: noconvergent norecurse nounwind
; TUNIT-LABEL: define {{[^@]+}}@convergent_intrinsic_noconvergent_callsite
; TUNIT-SAME: () #[[ATTR4]] {
; TUNIT-NEXT:    call void @llvm.nvvm.barrier0() #[[ATTR1]]
; TUNIT-NEXT:    ret i32 0
;
; CGSCC: Function Attrs: noconvergent norecurse nounwind
; CGSCC-LABEL: define {{[^@]+}}@convergent_intrinsic_noconvergent_callsite
; CGSCC-SAME: () #[[ATTR5]] {
; CGSCC-NEXT:    call void @llvm.nvvm.barrier0() #[[ATTR2]]
; CGSCC-NEXT:    ret i32 0
;
  call void @llvm.nvvm.barrier0() noconvergent
  ret i32 0
}

define i32 @recursive1() {
; TUNIT: Function Attrs: noconvergent nofree nosync nounwind willreturn memory(none)
; TUNIT-LABEL: define {{[^@]+}}@recursive1
; TUNIT-SAME: () #[[ATTR5:[0-9]+]] {
; TUNIT-NEXT:    ret i32 undef
;
; CGSCC: Function Attrs: noconvergent nofree norecurse nosync nounwind willreturn memory(none)
; CGSCC-LABEL: define {{[^@]+}}@recursive1
; CGSCC-SAME: () #[[ATTR1]] {
; CGSCC-NEXT:    ret i32 undef
;
  %a = call i32 @recursive2()
  ret i32 %a
}

define i32 @recursive2() {
; TUNIT: Function Attrs: noconvergent nofree nosync nounwind willreturn memory(none)
; TUNIT-LABEL: define {{[^@]+}}@recursive2
; TUNIT-SAME: () #[[ATTR5]] {
; TUNIT-NEXT:    ret i32 undef
;
; CGSCC: Function Attrs: noconvergent nofree norecurse nosync nounwind willreturn memory(none)
; CGSCC-LABEL: define {{[^@]+}}@recursive2
; CGSCC-SAME: () #[[ATTR1]] {
; CGSCC-NEXT:    ret i32 undef
;
  %a = call i32 @recursive1()
  ret i32 %a
}

define i32 @noopt() optnone noinline {
; CHECK: Function Attrs: noinline optnone
; CHECK-LABEL: define {{[^@]+}}@noopt
; CHECK-SAME: () #[[ATTR6:[0-9]+]] {
; CHECK-NEXT:    [[A:%.*]] = call i32 @noopt_friend()
; CHECK-NEXT:    ret i32 0
;
  %a = call i32 @noopt_friend()
  ret i32 0
}

; A function which is mutually-recursive with a convergent, optnone function
; shouldn't have noconvergent attribute added.
define i32 @noopt_friend() {
; CHECK-LABEL: define {{[^@]+}}@noopt_friend() {
; CHECK-NEXT:    [[A:%.*]] = call i32 @noopt()
; CHECK-NEXT:    ret i32 0
;
  %a = call i32 @noopt()
  ret i32 0
}
;.
; TUNIT: attributes #[[ATTR0]] = { noconvergent nofree norecurse nosync nounwind willreturn memory(none) }
; TUNIT: attributes #[[ATTR1]] = { noconvergent }
; TUNIT: attributes #[[ATTR2]] = { norecurse }
; TUNIT: attributes #[[ATTR3:[0-9]+]] = { nocallback nounwind }
; TUNIT: attributes #[[ATTR4]] = { noconvergent norecurse nounwind }
; TUNIT: attributes #[[ATTR5]] = { noconvergent nofree nosync nounwind willreturn memory(none) }
; TUNIT: attributes #[[ATTR6]] = { noinline optnone }
;.
; CGSCC: attributes #[[ATTR0]] = { noconvergent nofree nosync nounwind willreturn memory(none) }
; CGSCC: attributes #[[ATTR1]] = { noconvergent nofree norecurse nosync nounwind willreturn memory(none) }
; CGSCC: attributes #[[ATTR2]] = { noconvergent }
; CGSCC: attributes #[[ATTR3]] = { norecurse }
; CGSCC: attributes #[[ATTR4:[0-9]+]] = { nocallback nounwind }
; CGSCC: attributes #[[ATTR5]] = { noconvergent norecurse nounwind }
; CGSCC: attributes #[[ATTR6]] = { noinline optnone }
; CGSCC: attributes #[[ATTR7]] = { willreturn }
;.
