; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals
; RUN: opt -S -passes=function-attrs < %s %s | FileCheck %s

define i32 @nonleaf() {
; CHECK: Function Attrs: mustprogress noconvergent nofree norecurse nosync nounwind willreturn memory(none)
; CHECK-LABEL: define {{[^@]+}}@nonleaf
; CHECK-SAME: () #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[A:%.*]] = call i32 @leaf()
; CHECK-NEXT:    ret i32 [[A]]
;
  %a = call i32 @leaf()
  ret i32 %a
}

define i32 @leaf() {
; CHECK: Function Attrs: mustprogress noconvergent nofree norecurse nosync nounwind willreturn memory(none)
; CHECK-LABEL: define {{[^@]+}}@leaf
; CHECK-SAME: () #[[ATTR0]] {
; CHECK-NEXT:    ret i32 0
;
  ret i32 0
}

declare i32 @extern_noconvergent() noconvergent

declare i32 @extern_convergent()

define i32 @call_extern_convergent() {
; CHECK-LABEL: define {{[^@]+}}@call_extern_convergent() {
; CHECK-NEXT:    [[A:%.*]] = call i32 @extern_convergent()
; CHECK-NEXT:    ret i32 [[A]]
;
  %a = call i32 @extern_convergent()
  ret i32 %a
}
;
define i32 @extern_noconvergent_call() {
; CHECK: Function Attrs: noconvergent
; CHECK-LABEL: define {{[^@]+}}@extern_noconvergent_call
; CHECK-SAME: () #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[A:%.*]] = call i32 @extern_noconvergent()
; CHECK-NEXT:    ret i32 [[A]]
;
  %a = call i32 @extern_noconvergent()
  ret i32 %a
}

; FIXME: This be inferred as noconvergent
define i32 @indirect_noconvergent_call(ptr %f) {
; CHECK-LABEL: define {{[^@]+}}@indirect_noconvergent_call
; CHECK-SAME: (ptr nocapture readonly [[F:%.*]]) {
; CHECK-NEXT:    [[A:%.*]] = call i32 [[F]]() #[[ATTR1]]
; CHECK-NEXT:    ret i32 [[A]]
;
  %a = call i32 %f() noconvergent
  ret i32 %a
}
; Give indirect_non_convergent_call the norecurse attribute so we get a
; "Function Attrs" comment in the output.

define i32 @indirect_non_convergent_call(ptr %f) norecurse {
; CHECK: Function Attrs: norecurse
; CHECK-LABEL: define {{[^@]+}}@indirect_non_convergent_call
; CHECK-SAME: (ptr nocapture readonly [[F:%.*]]) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:    [[A:%.*]] = call i32 [[F]]()
; CHECK-NEXT:    ret i32 [[A]]
;
  %a = call i32 %f()
  ret i32 %a
}

declare void @llvm.nvvm.barrier0()

define i32 @intrinsic() {
  ; Implicitly convergent, because the intrinsic is convergent.
; CHECK: Function Attrs: nounwind
; CHECK-LABEL: define {{[^@]+}}@intrinsic
; CHECK-SAME: () #[[ATTR4:[0-9]+]] {
; CHECK-NEXT:    call void @llvm.nvvm.barrier0()
; CHECK-NEXT:    ret i32 0
;
  call void @llvm.nvvm.barrier0()
  ret i32 0
}

define i32 @convergent_intrinsic_noconvergent_callsite() {
; CHECK: Function Attrs: noconvergent nounwind
; CHECK-LABEL: define {{[^@]+}}@convergent_intrinsic_noconvergent_callsite
; CHECK-SAME: () #[[ATTR5:[0-9]+]] {
; CHECK-NEXT:    call void @llvm.nvvm.barrier0() #[[ATTR1]]
; CHECK-NEXT:    ret i32 0
;
  call void @llvm.nvvm.barrier0() noconvergent
  ret i32 0
}

define i32 @recursive1() {
; CHECK: Function Attrs: noconvergent nofree nosync nounwind memory(none)
; CHECK-LABEL: define {{[^@]+}}@recursive1
; CHECK-SAME: () #[[ATTR6:[0-9]+]] {
; CHECK-NEXT:    [[A:%.*]] = call i32 @recursive2()
; CHECK-NEXT:    ret i32 [[A]]
;
  %a = call i32 @recursive2()
  ret i32 %a
}

define i32 @recursive2() {
; CHECK: Function Attrs: noconvergent nofree nosync nounwind memory(none)
; CHECK-LABEL: define {{[^@]+}}@recursive2
; CHECK-SAME: () #[[ATTR6]] {
; CHECK-NEXT:    [[A:%.*]] = call i32 @recursive1()
; CHECK-NEXT:    ret i32 [[A]]
;
  %a = call i32 @recursive1()
  ret i32 %a
}

define i32 @noopt() optnone noinline {
; CHECK: Function Attrs: noinline optnone
; CHECK-LABEL: define {{[^@]+}}@noopt
; CHECK-SAME: () #[[ATTR7:[0-9]+]] {
; CHECK-NEXT:    [[A:%.*]] = call i32 @noopt_friend()
; CHECK-NEXT:    ret i32 0
;
  %a = call i32 @noopt_friend()
  ret i32 0
}

; A function which is mutually-recursive with a convergent, optnone function
; shouldn't have noconvergent attribute added.
define i32 @noopt_friend() {
; CHECK-LABEL: define {{[^@]+}}@noopt_friend() {
; CHECK-NEXT:    [[A:%.*]] = call i32 @noopt()
; CHECK-NEXT:    ret i32 0
;
  %a = call i32 @noopt()
  ret i32 0
}
;.
; CHECK: attributes #[[ATTR0]] = { mustprogress noconvergent nofree norecurse nosync nounwind willreturn memory(none) }
; CHECK: attributes #[[ATTR1]] = { noconvergent }
; CHECK: attributes #[[ATTR2]] = { norecurse }
; CHECK: attributes #[[ATTR3:[0-9]+]] = { nocallback nounwind }
; CHECK: attributes #[[ATTR4]] = { nounwind }
; CHECK: attributes #[[ATTR5]] = { noconvergent nounwind }
; CHECK: attributes #[[ATTR6]] = { noconvergent nofree nosync nounwind memory(none) }
; CHECK: attributes #[[ATTR7]] = { noinline optnone }
;.
